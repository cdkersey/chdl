CHDL Near-term Roadmap
======================

_ Add tri-state support
  . To simulation
  _ To .nand format (including in/out ports)
    . Internal nodes
    _ in/out ports
  _ To optimizer
    . fanout reducer should store position; tristate (and memory) nodes
      may have multiple fanouts from same input, so just matching node number is
      insufficient. 
    _ tri x y x z x w q p => tri x orN({y,z,w}) q p
    _ tri x y => x
      - But not on i/o pins
  _ To technology mapper and .netl format (three-state buffers are positional
    [non-commutative] 2-input gates)

_ Add tri-state multi-line "bus" that extends bvec and adds a
  'connect(bvec<N> input, node enable)' function

_ Add basic register optimization
  _ unused reg values are dead nodes
  _ reg(Lit(x)) = Lit(x)
  _ registers with the same input expressions can be combined (during common
    subexpn elim)

_ Add "don't care" support
  _ A "whatever" lit type; evals to 0
  _ 'template <unsigned N> bvec<N> Whatever()' utility function in lit.h
  _ optimizations: inv(whatever) = whatever, reg(whatever) = whatever
     - Treat whatevers like constant 0 or 1, based on which will reduce
       logic more (will propagate 0 to the most nand gates)
  _ eval options for simulation?

_ Create a separate header for utility functions, integer math, etc.
  - like the int log2 functions

_ Make mux use CLOG2, so input vectors don't have to involve powers of 2.
  - this will enable better optimization.

_ Fix handling of memory in vis.cpp
  - Currently the outputs are just unattached hexagons and the address nodes
    are not indicated at all.

_ Add optimizations for tri-state logic
  - A tri-state node that can only be driven by one input just becomes that
    input. Its enable becomes a dangling node.
  - Any pair of inputs to a tri-state node that have the same value can be
    reduced to a single driver whose enable signal is or(e0, e1)

_ Create some documentation.
  - Make the CHDL manual more than just an imcomplete outline.

Possible future features:
  _ Change nand-based IR to industry-standard AIG (and/inverter graph)
    - This is implementation technology neutral, whereas our nand/inverter graph
      will, once optimized, not tmap to nor gates easily.
  _ Netlist reading
  _ Pass manager
    - Is there any reason to optimize in an order other than the one used by
      the optimize function?
    - Could technology mapping be handled by this same pass manager?
