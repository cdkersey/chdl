CHDL Near-term Roadmap
======================

_ Add gate transition matrices for power modeling.
  - N inputs -> 2^N x 2^N transition matrix

_ Add tri-state support
  . To .nand format (including in/out ports)
    . in/out ports (called "inout")
  . To technology mapper and .netl format (three-state buffers are positional
    [non-commutative] 2-input gates)
    . in/out ports for technology mapper
    . technology mapper itself
    . (external) .netl file reader
  _ To verilog output (FPGA verified)

_ A directory full of simple unit tests.
  - One for each function exposed in a header file.

_ Some sort of context management.
  . As a start, add a global state reset function. chdl::reset(). This will
    enable unit tests.
  - CHDL is a stateful library. In some cases (like unit tests) it is nice to
    have multiple states which can be swapped in and out, preferably (using
    TLS) in a threadsafe manner. The idea:

      - Replace all global state variables with funcs that return references.
      - Add a global state function to 
      - Use a macro to define these variables.

_ Testing
  - In additon to the current "correctness" tests and examples, performance
    regressions and more complicated module synthesis and correctness tests are
    necessary. Some possibilities:
      - Multi-module examples with verilog top-level files to test inputs and
        outputs
      - Tests of optimization including number of gates and critical path.
      - Records of improvements to optimization (with nontrivial designs) over
        time.

_ Rebalancing optimization
  _ Normalize to chains [And(And(And(And(a), b), c), d)]. These are easier to
    route(probably; check), but O(n) in both time and space.
  . Rebalance to trees [And(And(a, b), And(c, d))] where necessary. These are
    O(n) in space but O(log(n)) in time.

_ Basic register optimization
  _ unused reg values are dead nodes
  _ reg(Lit(x)) = Lit(x)
  _ registers with the same input expressions can be combined (during common
    subexpn elim)

_ "don't care" support
  . A "whatever" lit type; evals to 0
    - Lit('x');
    - Lit('0') and Lit('1') also work now too.
  _ 'template <unsigned N> bvec<N> Whatever()' utility function
  _ optimizations:
     - Treat whatevers like constant 0 or 1, based on which will reduce
       logic more (will propagate 0 to the most nand gates)
  _ eval options for simulation?

_ Create a separate header for utility functions, integer math, etc.
  - like the int log2 functions

_ Make mux use CLOG2, so input vectors don't have to involve powers of 2.
  - this will enable better optimization.

_ Fix handling of memory in vis.cpp
  - Currently the outputs are just unattached hexagons and the address nodes
    are not indicated at all.

_ Create some documentation.
  - Make the CHDL manual more than just an imcomplete outline.
  - Write an introductory tutorial in digital design using CHDL, Verilog, and
    VHDL to provide examples.

_ Custom literal type overload with universal literal type class
  - Allows us to say "1_cl" instead of "Lit<N>(1)". A little more terse.

_ Split off CHDL standard library as its own project.
  - This includes all non-hardware-mappable objects, tests, and examples:
    - LLRom, LLRam
    - State machines

    - Possibly including:
      - Non-elementary gates
      - vec, bvec, and bitwise operations
      - Arithmetic and comparison

    - Definitely not including
      - Fundamental logic types:
        - Nand (or and if we make the switch to AIG), Inverter
        - Register
        - Memory (synchronous and asynchronous SRAM and ROM)
      - Basic optimizations
      - Technology mapping
      - Simulation interfaces (eval, tickable, nodeimpl)

_ Make dead node elimination use the criterion that node objects exist for a
  given node id/nodeimpl. Make this give us things like taps and gtaps for
  free.

Possible future features:
  _ Change nand-based IR to industry-standard AIG (and/inverter graph)
    - This is implementation technology neutral, whereas our nand/inverter graph
      will, once optimized, not tmap to nor gates easily.
  _ Netlist reading
  _ Pass manager
    - Is there any reason to optimize in an order other than the one used by
      the optimize function?
      - Yes. Dependence on analyses. It would be nice to, say, only have to find
        the successor map once.
    - Could technology mapping be handled by this same pass manager?
  _ Command-line/scripting support
    - Even instantiate gates through some sort of readline-based interface.
  _ Verilog or VHDL input
    - It comes full-circle.
