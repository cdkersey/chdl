C++ Hardware Description Library
================================

CHDL (call it "the" CHDL at your peril) is a domain-specific language based on
C++. Specifically, it attmpts to fill the role of a "structural" hardware
description language for implementing designs.

A simple design, a full adder, implemented in CHDL, might look like the
following:

  #include <chdl/gates.h>
  #include <chdl/gateops.h>

  node FullAdder(node cout, node cin, node a, node b) {
    node h = Xor(a, b), s = Xor(h, cin);
    cout = (a && b) || (h && cin);
    return s;
  }

Adders are already provided in the CHDL library, so a device of this nature
would not be completely necessary.

Contents
--------

  - Concepts
    - Gate-Level Design
    - Node
      - The node class
      - nodeType enumeration
      - Creating New Node Types
        - The nodeimpl hierarchy
    - Register
    - Vector
  - API
    - Nodes
      - Literals
      - Fundamental Gates
      - Registers
      - Special Nodes
      - Tri-state Nodes
    - Gates
    - Basic Operator Overloads (&&, ||, !)
    - Vectors
    - Vector Operator Overloads (&, |, ^, <<, >>, +, -, *, /, -, ~, ==, !=)
    - Vector Concatenation (Cat(vec, vec) Cat(vec, node) Cat(vec).Cat(vec)...)
    - Encoders and Decoders
    - Higher-order Arrays
      - Flatten
    - chdl::sz<T> Template
    - Multiplexers
    - Conditional Assignment (Cassign)
    - Buses
    - Arithmetic
    - Memories
    - Optimization
    - Simulator
      - C++ Interoperability (Ingress/Egress)
      - Assertions
    - Analysis
      - Cycle Detection
      - Critical Path Length
      - Critical Path Report
    - HDL Writer
  - Simulation Tools

  - File Formats
    - NAND File Format
    - NETL File Format
    - TLIB File Format
  - HDL Writer
  - Technology Mapper
  - Frequently-Asked Questions

Concepts
--------

  Gate-Level Design
  -----------------

Designs expressed using CHDL are ultimately expressed at the gate level. While
many layers of abstraction may separate the design of a complex hardware device
from the level of gates, a program using CHDL is ultimately a C++ program
describing a set of fundamental logic units, or gates, the connections between
them, and the organization of their inputs and outputs.

A very simple gate-level design is the following 1-bit adder. It adds two 1-bit
numbers together, producing a 2-bit result. This device is often referred to as
a "half adder":

  sum[1] = And(a, b);
  sum[0] = Inv(Nand(Nand(Inv(a), Inv(b)), Nand(a, b)));

Note that it is represented with only two kinds of gates, nand gates and
inverters. For the sake of simplicity, all gate-level designs in CHDL are
represented internally as a combination of only two kinds of basic gates. (In
addition to special nodes for sequential logic and things like memory and
tri-state objects that are not easy to represent as combinations of gates.)

  Node
  ----

A "node" in a gate-level design can be thought of as a net in a circuit. Each
node in a design is an independent entity that may take on a logic value during
the simulation of the design. Because each node represents the output of a gate
or an input to a circuit, the nodes themselves are considered synonymous with
the objects of which they are outputs.

  Register
  --------

In the context of CHDL design, registers can be thought of as simple delay
elements. There is an implicit global clock signal making periodic transitions
from low to high, and registers all take output generated during one clock cycle
and delay it until the next low-to-high transition of the clock signal.

  Vector
  ------

Signals in CHDL are often grouped together into bundles. The most basic way to
bundle signals is as vectors of nodes. These fixed-length addressible structures
provide a simple method for accessing individual elements from C++ code,
including loops. In the following example, a 4-element vector is created and
then set up as a simple shift register:

  node input, output;
  bvec<4> shreg;

  for (unsigned i = 0; i < 4; ++i)
    shreg[i] = Reg(i == 0 ? input : shreg[i - 1]); 

  output = shreg[3];

API
---

 Nodes
 -----

A CHDL node can be thought of as a node (also known as a net) in a digital
circuit. The chdl::node object itself is a referential type, representing an
index of a node implementation in CHDL's internal state. Using this approach,
it is ensured that assignment to a chdl::node will not only affect its sub-
sequent uses, but all prior uses as well:

  node next_x, x(Reg(next_x)),
       next_y, y(Reg(next_y)),
       next_z, z(Reg(next_z));

  next_x = Inv(x);
  next_y = Xor(x, y);
  next_z = Xor(And(x, y), z);

The downside to this is that copies performed by container objects, formerly
benign, now have the capacity to unwittingly overwrite nodes.

 Literals
 --------

A literal in CHDL is a node with a time-constant value:

  node x = Inv(Lit(0)),
       y = And(x, Lit(1));

Literals are typically used as arguments to functions:

  node val = Mux(a, Mux(b, Lit(0), Lit(1)), Lit(1));

The CHDL optimization system ensures that these are efficiently compacted, often
disappearing altogether. For example, Or(And(Lit(1), x), y).

 Gates
 -----

Internally, CHDL represents designs as a set of fundamental logic gates and
registers. The CHDL API hides the details (e.g. which gates these are) from the
user and provides the usual complement of basic logic gates:

  node x_and_y = And(x, y),
       x_nand_y = Nand(x, y),
       x_or_y = Or(x, y),
       x_nor_y = Nor(x, y),
       x_xor_y = Xor(x, y),
       x_2mux_y = Mux(z, x, y);

 Basic Operator Overloads
 ------------------------

C++ logical operators have been overloaded to provide an infix notation for
common logical operations:

  node x_and_y = x && y,
       x_nand_y = !(x && y),
       x_or_y = x || y,
       x_nor_y = !(x || y),
       x_xor_y = x != y,
       x_xnor_y = x == y;

Conspicuously absent is the use of the ternary (? :) operator to provide a
basic multiplexor function. This cannot be provided due to a fundamental
limitation of C++.

 Vectors
 -------

 Vector Operator Overloads
 -------------------------

  TODO: [range<>()]

 Vector Concatenation
 --------------------

 Encoders and Decoders
 ---------------------

 Higher-order Arrays
 -------------------

  Flatten
  -------

 chdl::sz<T> Template
 -----------------

 A convenient tempalate interface is provided to obtain the (compile-time
 static) number of nodes contained in any object, including arrays of any
 number of dimensions. For instance, when flattening a multi-dimensional array,
 the size of the containing bvec can be determined using sz<T>:

   typedef vec<N, vec<M, bvec<8> > > v_t;
     
   v_t v;

   . . .

   bvec<sz<v_t>::value> flat = Flatten(v);

This is, in fact, how the size of the Flatten template's return type is defined.

 Multiplexers
 ------------

 Conditional Assignment
 ----------------------

The hierarchies of multiplexers needed to perform even the most basic tasks can
create opaque, difficult-to-understand code. Consider the task of implementing
an up/down counter with reset. The next value, in pseudocode would be:

  if (reset)
    ctr = 0;
  else if (count_up && !count_down)
    ctr = ctr + 1;
  else if (count_down && !count_up)
    ctr = ctr - 1;
  else
    ctr = ctr;

In the portion of CHDL covered so far, this could be implemented with multi-
plexers:

  bvec<N> ctr_next, ctr(Reg(ctr_next));
  
  ctr_next = Mux(reset,
               Mux(count_up && !count_down,
                 Mux(count_down && !count_up, ctr, ctr - Lit<N>(1)),
               ctr + Lit<N>(1)),
             Lit<N>(0));

Even with the best organization, this statement is rather hard to grok. For
these kinds of conditionals, a muliplexer with its inputs reversed would lead to
slightly easier-to-understand code:

  ctr_next = If(reset,
               Lit<N>(0),
               If(count_up && !count_down,
                 ctr + Lit<N>(1),
                 If(count_down && !count_up,
                    ctr - Lit<N>(1),
                    ctr)));

but this is only about as readable as the typical conditonal statement in LISP.
This reversed-input multiplexer is not a part of CHDL. Instead, CHDL provides
Cassign(), a conditional assignment framework. Using Cassign, this statement be-
comes:

  Cassign(ctr_next).
    IF(reset, Lit<N>(0)).
    IF(count_up && !count_down, ctr + Lit<N>(1)).
    IF(count_down && !count_up, ctr - Lit<N>(1)).
    ELSE(ctr);

One of the more powerful aspects of Cassign() is its support for nested con-
ditionals. If, say, you wanted to, in the event of a reset with one of the count
lines held high, reset to a value of +1 or -1 accordingly, this could be done
with a nested conditional:

  Cassign(ctr_next).
    IF(reset).
      IF(count_up && !count_down, Lit<N>(1)).
      IF(count_down && !count_up, Lit<N>(-1)).
      ELSE(Lit<N>(0)).
    END().
    IF(count_up && !count_down, ctr + Lit<N>(1)).
    IF(count_down && !count_up, ctr - Lit<N>(1)).
    ELSE(ctr);

 Buses
 -----

 Arithmetic
 ----------

 Memories
 --------

 Optimization
 ------------

 Simulator
 ---------

  C++ Interoperability (Ingress/Egress)
  -------------------------------------

  Assertions
  ----------

  CHDL provides a system for error detection using assertions. The ASSERT()
  macro provides an easy interface for creating simulation-time assertions.
  If the node passed to the ASSERT() macro is ever false during simulation, the
  simulation is stopped and an error message is printed. In the following
  example, if the simulation runs for more than 128 cycles, an error message is
  printed:

    bvec<8> counter;
    counter = Reg(counter + Lit<8>(1));
  
    ASSERT(!counter[7]);

 Analysis
 --------

  Cycle Detection
  ---------------

  Critical Path Length
  --------------------

  Critical Path Report
  --------------------

File Formats
------------

 NAND File Format
 ----------------

A very basic netlist format has been developed for storing CHDL designs for use
by other utilities. This file is called a "nand" file because all logic is
represented (currently) as a network of nand gates and inverters. Each node is

 NETL File Format
 ----------------

The NETL file format produced by the technology mapper follows the same basic
netlist structure as the NAND file format but allows a richer set of primitives
instead of the basic NAND-inverter graph of the NAND format.

 TLIB File Format
 ----------------

The TLIB format is used to define a technology library as a set of gates to be
matched. Each line contains the name of a gate, followed by whitespace,
followed by a polish expression for the NAND-inverter tree that matches that
gate. This structure must be a tree in form, but leaf nodes (inputs) can
represent the same input.

As an example, let's write a 2-input XOR gate in TLIB format:

  xor2 inn12ni1i2

"xor2" is obviously the name of the gate. The string on the right is the
structure of the gate; a tree output in depth-first form:

            i
            |
            n
          /   \
        n       n
       / \     / \
      1   2   i   i
              |   |
              1   2

HDL Writer
----------

Technology Mapper
-----------------

Frequently-Asked Questions
--------------------------

Q: I want to create a simple sequential circuit, like a counter, but my attempt:

    bvec<4> ctr1(Reg(ctr1 + Lit<4>(1))); //, or
    bvec<4> ctr2 = Reg(ctr2 + Lit<4>(1));

   does not seem to work. In fact, it behaves very strangely. What am I doing
   wrong?

A: Use two statements instead:

     bvec<4> ctr; ctr = Reg(ctr + Lit<4>(1));

   Why is this unfortunate verbosity necessary? Currently, CHDL relies on the
   bvec object "ctr" being constructed before it can be used. The reference to
   "ctr" in "ctr + Lit<4>(1)" leads to undefined behavior in C++ because ctr
   has not been constructed yet. So, while it is syntactically valid C++, it is
   semantically ambiguous.
