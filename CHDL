C++ Hardware Description Library
================================

CHDL (call it "the" CHDL at your peril) is a domain-specific language based on
C++. Specifically, it attmpts to fill the role of a "structural" hardware
description language for implementing designs.

A simple design, a full adder, implemented in CHDL, might look like the
following:

  #include <chdl/gates.h>
  #include <chdl/gateops.h>

  node FullAdder(node cout, node cin, node a, node b) {
    node h = Xor(a, b), s = Xor(h, cin);
    cout = (a && b) || (h && cin);
    return s;
  }

Adders are already provided in the CHDL library, so a device of this nature
would not be completely necessary.

Contents
--------

  - Concepts
    - Gate-Level Design
    - Node
      - The node class
      - nodeType enumeration
      - Creating New Node Types
        - The nodeimpl hierarchy
    - Register
    - Vector
  - API
    - CLOG2() and Log2() Utility Functions
    - Nodes
      - Literals
      - Fundamental Gates
      - Registers
      - Special Nodes
      - Tri-state Nodes
      - Module Inputs
    - Gates
    - Basic Operator Overloads (&&, ||, !)
    - Vectors
    - Vector Operator Overloads ([], &, |, ^, <<, >>, +, -, *, /, -, ~, ==, !=)
      - Indexing
      - Logic
      - Arithmetic
      - Equality
      - Shift
    - Vector Concatenation (Cat(vec, vec) Cat(vec, node) Cat(vec).Cat(vec)...)
    - Encoders and Decoders
    - Higher-order Arrays
      - Flatten
    - chdl::sz<T> Template
    - Multiplexers
    - Conditional Assignment (Cassign)
    - Buses
    - Inputs and Ouputs
    - Arithmetic
    - Memories
    - Optimization
    - Simulator
      - C++ Interoperability (Ingress/Egress)
      - Assertions
    - Analysis
      - Cycle Detection
      - Critical Path Length
      - Critical Path Report
    - HDL Writer
  - Simulation Tools

  - File Formats
    - NAND File Format
    - NETL File Format
    - TLIB File Format
  - HDL Writer
  - Technology Mapper
  - Frequently-Asked Questions

Concepts
--------

  Gate-Level Design
  -----------------

Designs expressed using CHDL are ultimately expressed at the gate level. While
many layers of abstraction may separate the design of a complex hardware device
from the level of gates, a program using CHDL is ultimately a C++ program
describing a set of fundamental logic units, or gates, the connections between
them, and the organization of their inputs and outputs.

A very simple gate-level design is the following 1-bit adder. It adds two 1-bit
numbers together, producing a 2-bit result. This device is often referred to as
a "half adder":

  sum[1] = And(a, b);
  sum[0] = Inv(Nand(Nand(Inv(a), Inv(b)), Nand(a, b)));

Note that it is represented with only two kinds of gates, nand gates and
inverters. For the sake of simplicity, all gate-level designs in CHDL are
represented internally as a combination of only two kinds of basic gates. (In
addition to special nodes for sequential logic and things like memory and
tri-state objects that are not easy to represent as combinations of gates.)

  Node
  ----

A "node" in a gate-level design can be thought of as a net in a circuit. Each
node in a design is an independent entity that may take on a logic value during
the simulation of the design. Because each node represents the output of a gate
or an input to a circuit, the nodes themselves are considered synonymous with
the objects of which they are outputs.

  Register
  --------

In the context of CHDL design, registers can be thought of as simple delay
elements. There is an implicit global clock signal making periodic transitions
from low to high, and registers all take output generated during one clock cycle
and delay it until the next low-to-high transition of the clock signal.

  Vector
  ------

Signals in CHDL are often grouped together into bundles. The most basic way to
bundle signals is as vectors of nodes. These fixed-length addressible structures
provide a simple method for accessing individual elements from C++ code,
including loops. In the following example, a 4-element vector is created and
then set up as a simple shift register:

  node input, output;
  bvec<4> shreg;

  for (unsigned i = 0; i < 4; ++i)
    shreg[i] = Reg(i == 0 ? input : shreg[i - 1]); 

  output = shreg[3];

API
---

  Capitalization and Style Conventions
  ------------------------------------

Compile-time constants are rendered in ALL_CAPS with underscores representing
word separation. This is true for both variables and constexpr functions like
chdl::CLOG2. Within CHDL, class names and variables are all rendered in lower
case with underscore_separators or camelCase. Functions representing ordinary
computation are in lowerCaseCamelCase() and functions representing hardware
modules of any type are rendered in CapitalCamelCase().

      Type of Identifier | Capitalization Example
    ---------------------+------------------------
      Constant value     | ALL_CAPS
      Constexpr function | ALL_CAPS()
      Variable           | lower_case, lowerCase
      Function           | log2(my_int)
      Function (hardware)| Log2(my_bvec)

With respect to the dimensions of code, the Linux kernel style guide
recommendation of eighty columns and no more than a couple of hundred lines per
function apply. Long lines are a curse to be dealt with by creative indentation.
Indentation should be done, of course, only with ' ' characters, never with
'\t'. Unlike Linux, the preference is for two-space indentations. This conceit
is mainly in place to compensate for the compact line size in header files.

For the sake of uniformity, projects implemented primarily with CHDL should
attempt to follow these style guidelines as well.

  CLOG2() and LOG2() Utility Functions
  ------------------------------------

Frequently in digital logic it is necessary to find the number of bits needed to
hold a certain number of states. This is the ceiling of the logarithm base two
of the number of states. We have provided a function, CLOG2, that can be used
anywhere a constant value can be used (it is evaluated at compile time) which
provides the ceiling of the logarithm base two. This is especially useful in the
function prototypes of generic components like encoders and decoders. For
instance:

  template<unsigned N> bvec<LOG2(N) + 1> PopCount(bvec<N> x);

Specifies a population count function. Its output will be in the range [0, N]
and so must have at least floor(log2(N)) + 1 bits of storage.

  Nodes
  -----

A CHDL node can be thought of as a node (also known as a net) in a digital
circuit. The chdl::node object itself is a referential type, representing an
index of a node implementation in CHDL's internal state. Using this approach,
it is ensured that assignment to a chdl::node will not only affect its sub-
sequent uses, but all prior uses as well:

  node next_x, x(Reg(next_x)),
       next_y, y(Reg(next_y)),
       next_z, z(Reg(next_z));

  next_x = Inv(x);
  next_y = Xor(x, y);
  next_z = Xor(And(x, y), z);

The downside to this is that copies performed by container objects, formerly
benign, now have the capacity to unwittingly overwrite nodes.

  Literals
  --------

A literal in CHDL is a node with a time-constant value:

  node x = Inv(Lit(0)),
       y = And(x, Lit(1));

Literals are typically used as arguments to functions:

  node val = Mux(a, Mux(b, Lit(0), Lit(1)), Lit(1));

The CHDL optimization system ensures that these are efficiently compacted, often
disappearing altogether. For example, Or(And(Lit(1), x), y).

  Gates
  -----

Internally, CHDL represents designs as a set of fundamental logic gates and
registers. The CHDL API hides the details (e.g. which gates these are) from the
user and provides the usual complement of basic logic gates:

  node x_and_y = And(x, y),
       x_nand_y = Nand(x, y),
       x_or_y = Or(x, y),
       x_nor_y = Nor(x, y),
       x_xor_y = Xor(x, y),
       x_2mux_y = Mux(z, x, y);

  Module Inputs
  -------------

Input nodes cannot be simulated, but do participate in synthesis and will
become, in netlist outputs, ports of the design. In a typical design, input
nodes will be part of the top level design used for synthesis, and these will
be replaced by other logic in a different top level design used for simulation.

The following code generates a simple synthesizeable design with one input port
called "in" and one output port called "out":

  node in = Input("in"), out = Inv(in);
  OUTPUT(out);

 Basic Operator Overloads
 ------------------------

C++ logical operators have been overloaded to provide an infix notation for
common logical operations:

  node x_and_y = x && y,
       x_nand_y = !(x && y),
       x_or_y = x || y,
       x_nor_y = !(x || y),
       x_xor_y = x != y,
       x_xnor_y = x == y;

Conspicuously absent is the use of the ternary (? :) operator to provide a
basic multiplexor function. This cannot be provided due to a fundamental
limitation of C++.

 Vectors
 -------

CHDL provides its own fixed-length vector class, vec<N, T>, and an alias
template for vec<N, node>, bvec<N>. Multi-dimensional vectors are simple vecs of
vecs, e.g. vec<M, vec<N, node> >, vec<M, vec<N, bvec<8> > >, etc.

 Vector Operator Overloads
 -------------------------

 Indexing
 --------

The most important operation provided by vec is the indexing operator []. The
input can be either an integer or a range<A, B> object. Examples of valid uses
of the indexing operator:

  bvec<8> x, y;

  for (unsigned i = 0; i < 8; ++i)
    x[i] = y[7 - i];


  bvec<32> a, b;
  bvec<16> c, d;

  c = a[range<0, 15>()];
  d = a[range<8, 23>()];

 Logic
 -----

Bitwise logic operations, equivalent to their C/C++ counterparts, are provided
for convenience, including &, |, ^, and ~.

 Arithmetic
 ----------

A full set of arithmetic operators are provided as well, but these must be used
with caution. While adders are cheap and multipliers only somewhat expensive,
frequent use of dividers can easily lead to intractable designs.

 Equality
 --------

 Shift
 -----

 Vector Concatenation
 --------------------

 Encoders and Decoders
 ---------------------

 Higher-order Arrays
 -------------------

  Flatten
  -------

 chdl::sz<T> Template
 -----------------

 A convenient tempalate interface is provided to obtain the (compile-time
 static) number of nodes contained in any object, including arrays of any
 number of dimensions. For instance, when flattening a multi-dimensional array,
 the size of the containing bvec can be determined using sz<T>:

   typedef vec<N, vec<M, bvec<8> > > v_t;
     
   v_t v;

   . . .

   bvec<sz<v_t>::value> flat = Flatten(v);

This is, in fact, how the size of the Flatten template's return type is defined.

 Multiplexers
 ------------

 Conditional Assignment
 ----------------------

The hierarchies of multiplexers needed to perform even the most basic tasks can
create opaque, difficult-to-understand code. Consider the task of implementing
an up/down counter with reset. The next value, in pseudocode, would be:

  if (reset)
    ctr = 0;
  else if (count_up && !count_down)
    ctr = ctr + 1;
  else if (count_down && !count_up)
    ctr = ctr - 1;
  else
    ctr = ctr;

In the portion of CHDL covered so far, this could be implemented with multi-
plexers:

  bvec<N> ctr_next, ctr(Reg(ctr_next));
  
  ctr_next = Mux(reset,
               Mux(count_up && !count_down,
                 Mux(count_down && !count_up, ctr, ctr - Lit<N>(1)),
               ctr + Lit<N>(1)),
             Lit<N>(0));

Even with the best organization, this statement is rather hard to grok. For
these kinds of conditionals, a muliplexer with its inputs reversed would lead to
slightly easier-to-understand code:

  ctr_next = If(reset,
               Lit<N>(0),
               If(count_up && !count_down,
                 ctr + Lit<N>(1),
                 If(count_down && !count_up,
                    ctr - Lit<N>(1),
                    ctr)));

but this is only about as readable as the typical conditonal statement in LISP.
This reversed-input multiplexer is not a part of CHDL. Instead, CHDL provides
Cassign(), a conditional assignment framework. Using Cassign, this statement be-
comes:

  Cassign(ctr_next).
    IF(reset, Lit<N>(0)).
    IF(count_up && !count_down, ctr + Lit<N>(1)).
    IF(count_down && !count_up, ctr - Lit<N>(1)).
    ELSE(ctr);

One of the more powerful aspects of Cassign() is its support for nested con-
ditionals. If, say, you wanted to, in the event of a reset with one of the count
lines held high, reset to a value of +1 or -1 accordingly, this could be done
with a nested conditional:

  Cassign(ctr_next).
    IF(reset).
      IF(count_up && !count_down, Lit<N>(1)).
      IF(count_down && !count_up, Lit<N>(-1)).
      ELSE(Lit<N>(0)).
    END().
    IF(count_up && !count_down, ctr + Lit<N>(1)).
    IF(count_down && !count_up, ctr - Lit<N>(1)).
    ELSE(ctr);

 Buses
 -----

 Inputs and Outputs
 ------------------

 Arithmetic
 ----------

 Memories
 --------

 Optimization
 ------------

 Simulator
 ---------

  C++ Interoperability (Ingress/Egress)
  -------------------------------------

  Assertions
  ----------

  CHDL provides a system for error detection using assertions. The ASSERT()
  macro provides an easy interface for creating simulation-time assertions.
  If the node passed to the ASSERT() macro is ever false during simulation, the
  simulation is stopped and an error message is printed. In the following
  example, if the simulation runs for more than 128 cycles, an error message is
  printed:

    bvec<8> counter;
    counter = Reg(counter + Lit<8>(1));
  
    ASSERT(!counter[7]);

 Analysis
 --------

  Cycle Detection
  ---------------

  Critical Path Length
  --------------------

  Critical Path Report
  --------------------

File Formats
------------

 NAND File Format
 ----------------

A very basic netlist format has been developed for storing CHDL designs for use
by other utilities. This file is called a "nand" file because all logic is
represented (currently) as a network of nand gates and inverters. Each node is

 NETL File Format
 ----------------

The NETL file format produced by the technology mapper follows the same basic
netlist structure as the NAND file format but allows a richer set of primitives
instead of the basic NAND-inverter graph of the NAND format.

 TLIB File Format
 ----------------

The TLIB format is used to define a technology library as a set of gates to be
matched. Each line contains the name of a gate, followed by whitespace,
followed by a polish expression for the NAND-inverter tree that matches that
gate. This structure must be a tree in form, but leaf nodes (inputs) can
represent the same input.

As an example, let's write a 2-input XOR gate in TLIB format:

  xor2 inn12ni1i2

"xor2" is obviously the name of the gate. The string on the right is the
structure of the gate; a tree output in depth-first form:

            i
            |
            n
          /   \
        n       n
       / \     / \
      1   2   i   i
              |   |
              1   2

HDL Writer
----------

Technology Mapper
-----------------

Frequently-Asked Questions
--------------------------

Q: I want to create a simple sequential circuit, like a counter, but my attempt:

    bvec<4> ctr1(Reg(ctr1 + Lit<4>(1))); //, or
    bvec<4> ctr2 = Reg(ctr2 + Lit<4>(1));

   does not seem to work. In fact, it behaves very strangely. What am I doing
   wrong?

A: Use two statements instead:

     bvec<4> ctr; ctr = Reg(ctr + Lit<4>(1));

   Why is this unfortunate verbosity necessary? Currently, CHDL relies on the
   bvec object "ctr" being constructed before it can be used. The reference to
   "ctr" in "ctr + Lit<4>(1)" leads to undefined behavior in C++ because ctr
   has not been constructed yet. So, while it is syntactically valid C++, it is
   semantically ambiguous.
