C++ Hardware Description Library
================================

CHDL (call it "the" CHDL at your peril) is a domain-specific language based on
C++. Specifically, it attmpts to fill the role of a "structural" hardware
description language for implementing designs.

A simple design, a full adder, implemented in CHDL, might look like the
following:

  #include <chdl/gates.h>
  #include <chdl/gateops.h>

  node FullAdder(node cout, node cin, node a, node b) {
    node h = Xor(a, b), s = Xor(h, cin);
    cout = (a && b) || (h && cin);
    return s;
  }

Adders are already provided in the CHDL library, so a device of this nature
would not be completely necessary.

Structure of this Document
--------------------------

  - Concepts
    - Register Transfer Level
    - Node
      - The node class
      - nodeType enumeration
      - Creating New Node Types
        - The nodeimpl hierarchy
    - Register
    - Vector
  - API
    - Nodes
      - Literals
      - Fundamental Gates
      - Registers
      - Special Nodes
      - Tri-state Nodes
    - Gates
    - Operator Overloads (&&, ||, !)
    - Vectors
    - Vector Operator Overloads (&, |, ^, <<, >>, +, -, *, /, -, ~, ==, !=)
    - Higher-order Arrays
    - Multiplexers
    - Conditional Assignment (Cassign)
    - Buses
    - Arithmetic
    - Memories
    - Optimization
    - Simulator
      - C++ Interoperability (Ingress/Egress)
    - HDL Writer
  - Simulation Tools
  - File Formats
    - NAND File Format
    - NETL File Format
    - TLIB File Format
  - HDL Writer
  - Technology Mapper
  - Frequently-Asked Questions

Concepts
--------

API
---

 Nodes
 -----

 Gates
 -----

 Operator Overloads
 ------------------

 Vectors
 -------

 Vector Operator Overloads
 -------------------------

 Higher-order Arrays
 -------------------

 Multiplexers
 ------------

 Conditional Assignment
 ----------------------

The hierarchies of multiplexers needed to perform even the most basic tasks can
create opaque, difficult-to-understand code. Consider the task of implementing
an up/down counter with reset. The next value, in pseudocode would be:

  if (reset)
    ctr = 0;
  else if (count_up && !count_down)
    ctr = ctr + 1;
  else if (count_down && !count_up)
    ctr = ctr - 1;
  else
    ctr = ctr;

In the portion of CHDL covered so far, this could be implemented with multi-
plexers:

  bvec<N> ctr_next, ctr(Reg(ctr_next));
  
  ctr_next = Mux(reset,
               Mux(count_up && !count_down,
                 Mux(count_down && !count_up, ctr, ctr - Lit<N>(1)),
               ctr + Lit<N>(1)),
             Lit<N>(0));

Even with the best organization, this statement is rather hard to grok. For
these kinds of conditionals, a muliplexer with its inputs reversed would lead to
slightly easier-to-understand code:

  ctr_next = If(reset,
               Lit<N>(0),
               If(count_up && !count_down,
                 ctr + Lit<N>(1),
                 If(count_down && !count_up,
                    ctr - Lit<N>(1),
                    ctr)));

but this is only about as readable as the typical conditonal statement in LISP.
This reversed-input multiplexer is not a part of CHDL. Instead, CHDL provides
Cassign(), a conditional assignment framework. Using Cassign, this statement be-
comes:

  Cassign(ctr_next).
    IF(reset, Lit<N>(0)).
    IF(count_up && !count_down, ctr + Lit<N>(1)).
    IF(count_down && !count_up, ctr - Lit<N>(1)).
    ELSE(ctr);

One of the more powerful aspects of Cassign() is its support for nested con-
ditionals. If, say, you wanted to, in the event of a reset with one of the count
lines held high, reset to a value of +1 or -1 accordingly, this could be done
with a nested conditional:

  Cassign(ctr_next).
    IF(reset).
      IF(count_up && !count_down, Lit<N>(1)).
      IF(count_down && !count_up, Lit<N>(-1)).
      ELSE(Lit<N>(0)).
    END().
    IF(count_up && !count_down, ctr + Lit<N>(1)).
    IF(count_down && !count_up, ctr - Lit<N>(1)).
    ELSE(ctr);

 Buses
 -----

 Arithmetic
 ----------

 Memories
 --------

 Optimization
 ------------

 Simulator
 ---------

  C++ Interoperability (Ingress/Egress)
  -------------------------------------

File Formats
------------

 NAND File Format
 ----------------

A very basic netlist format has been developed for storing CHDL designs for use
by other utilities. This file is called a "nand" file because all logic is
represented (currently) as a network of nand gates and inverters. Each node is

 NETL File Format
 ----------------

The NETL file format produced by the technology mapper follows the same basic
netlist structure as the NAND file format but allows a richer set of primitives
instead of the basic NAND-inverter graph of the NAND format.

 TLIB File Format
 ----------------

The TLIB format is used to define a technology library as a set of gates to be
matched. Each line contains the name of a gate, followed by whitespace,
followed by a polish expression for the NAND-inverter tree that matches that
gate. This structure must be a tree in form, but leaf nodes (inputs) can
represent the same input.

As an example, let's write a 2-input XOR gate in TLIB format:

  xor2 inn12ni1i2

"xor2" is obviously the name of the gate. The string on the right is the
structure of the gate; a tree output in depth-first form:

            i
            |
            n
          /   \
        n       n
       / \     / \
      1   2   i   i
              |   |
              1   2

HDL Writer
----------

Technology Mapper
-----------------

Frequently-Asked Questions
--------------------------

Q: I want to create a simple sequential circuit, like a counter, but my attempt:

    bvec<4> ctr1(Reg(ctr1 + Lit<4>(1))); //, or
    bvec<4> ctr2 = Reg(ctr2 + Lit<4>(1));

   does not seem to work. In fact, it behaves very strangely. What am I doing
   wrong?

A: Use two statements instead:

     bvec<4> ctr; ctr = Reg(ctr + Lit<4>(1));

   Why is this unfortunate verbosity necessary? Currently, CHDL relies on the
   bvec object "ctr" being constructed before it can be used. The reference to
   "ctr" in "ctr + Lit<4>(1)" leads to undefined behavior in C++ because ctr
   has not been constructed yet. So, while it is syntactically valid C++, it is
   semantically ambiguous.
